(libload "libc/make")
(libload "../ca/random.lsh")
(libload "../ca/ca2d_log.lsh")
(libload "../setup.lsh")

(defmacro i_vector args
  (let* ((l (length args)) (v (gensym)) (vs (.cl v)))
    (prog1
        `(let* ((,v (int-array ,l)))
           ,@(mapcar list vs (range* l) args)
           ,v)
      (delete vs) )))

(defclass RectBound ca2d_log ;CellularAutomaton2D
  ;;coordinates of inside rectanle (x,y) (q,z), x,y exclusive, q,z inclusive
  ((-int-) n_rows n_cols cor_x cor_y cor_q cor_z)
  ;;ambient density: dens_o inside rect density: dens_i
  ((-double-) dens_o dens_i fitness))

(defmethod RectBound RectBound (m n t_dens_o t_dens_i iter)
  (cpheader "#include \"../random.h\"")
  (declare (-int-) m n iter) 
  (declare (-double-) t_dens_o t_dens_i)
  (==> this ca2d_log m n iter)
  ;;(==> this CellularAutomaton2D  m n) ;;inherits constructor
  (setq n_rows m)
  (setq n_cols n)
  (setq dens_i t_dens_i)
  (setq dens_o t_dens_o)
)


;;Initialize rect bounding object (IC)
;; *set coordinates of internal rect - min rect width and height is 2x MINxWIDTH and 2xMINxHIGHT
;; *create denser internal rect if BLACKxRECT=1 or reverse if BLACKxRECT=0
;; if dens_i dens_o are not initilized, or are the same, or not differ by DENSxDIFF
;;     *initial densities are generated and differ at least DENSxDIFF from each other
;; o.w. use dens_i dens_o
(defmethod RectBound init ()
  (let* ((rect_offset 2)
	 (c_half (+ (floor (/ n_cols 2)) 0))
	 (r_half (+ (floor (/ n_rows 2)) 0)))
    (declare (-int-) rect_offset r_half c_half); rand_x rand_y rand_q rand_z)

    ;;generate inside and outside densities /must differ by min10%
    (while (or (< (abs (- dens_o dens_i)) DENSxDIFF) 
	       (> dens_o 1) (> dens_i 1)
	       (< dens_o 0) (< dens_i 0))  ;;difference between inside and outside dens must be at least 10%
      (setq dens_o (to-double #{uniform()#}))
      (setq dens_i (to-double #{uniform()#})))

    ;;swap densities so outside is lighter than inside
    (if (and (= BLACKxRECT 1) (> dens_o dens_i))
      (let ((tmp dens_o))
	(setq dens_o dens_i)
	(setq dens_i tmp)))

    ;;swap densities so outside is darker than inside
    (if (and (= BLACKxRECT 0) (< dens_o dens_i))
      (let ((tmp dens_o))
	(setq dens_o dens_i)
	(setq dens_i tmp)))
    
    ;;generate coordinates of inside rect
    (setq cor_x (to-int #{rnm(1, $(- r_half rect_offset))#} ))
    (setq cor_y (to-int #{rnm(1, $(- c_half rect_offset))#} ))
    (setq cor_q (to-int #{rnm($r_half, $(- n_rows rect_offset))#} ))
    (setq cor_z (to-int #{rnm($c_half, $(- n_cols rect_offset))#} ))

    (==> this make-random-state dens_o)
    (assert (and (> cor_x 0)(> cor_y 0)(< cor_q (- n_rows 1))(< cor_z (- n_cols 1))(> (- cor_q cor_x) 1)(> (- cor_z cor_y) 1))
	    (sprintf "RECT_BOUND.INIT: Out of bounds index dens_i= %f dens_o= %f x=%d y=%d q=%d z=%d rect %d x %d \n" dens_i dens_o cor_x cor_y cor_q cor_z(- cor_q cor_x) (- cor_z cor_y) ))

    (let* ((ic (==> this get_ic))
	   (ic_i (idx-trim* ic (- cor_q cor_x) (- cor_z cor_y))))
      (declare (-idx2- (-ubyte-)) ic ic_i)

      ;;shift over internal rect to x, y cord
      (idx-shift! ic_i 0 cor_x)
      (idx-shift! ic_i 1 cor_y)
      
      ;;initialize internal rect with dens_i
      (for* (i 0 (idx-shape ic_i 0)) 
 	(for* (j 0 (idx-shape ic_i 1)) 
 	  (declare (-int-) i j)
	  (if (<= (to-double #{uniform()#}) dens_i)     
	      (ic_i i j 1)
	    (ic_i i j 0))))
      (==> this set_ic ic)
      ic)
    ))

;;Initialize rect bounding object (IC)
;; *set coordinates of internal rect - min rect width and height is 2x MINxWIDTH and 2xMINxHIGHT
;; *create denser internal rect if BLACKxRECT=1 or reverse if BLACKxRECT=0
;; if dens_i dens_o are not initilized, or are the same, or not differ by DENSxDIFF
;;     *initial densities are generated and differ at least DENSxDIFF from each other
;; o.w. use dens_i dens_o
(defmethod RectBound init_box (n_points)
  (declare (-int-) n_points)
  (let* ((rect_offset 5)
;	 (c_half (+ (floor (/ n_cols 2)) 0))
;	 (r_half (+ (floor (/ n_rows 2)) 0))
	 )
    (declare (-int-) rect_offset); rand_x rand_y rand_q rand_z)

    ;;generate inside and outside densities /must differ by min10%
;    (while (or (< (abs (- dens_o dens_i)) DENSxDIFF) 
;	       (> dens_o 1) (> dens_i 1)
;	       (< dens_o 0) (< dens_i 0))  ;;difference between inside and outside dens must be at least 10%
;      (setq dens_o 0)
;      (setq dens_i 0.01)
;      )

    ;;generate coordinates of inside rect
;    (setq cor_x (to-int #{rnm(1, $(- r_half rect_offset))#} ))
;    (setq cor_y (to-int #{rnm(1, $(- c_half rect_offset))#} ))
;    (setq cor_q (to-int #{rnm($r_half, $(- n_rows rect_offset))#} ))
;    (setq cor_z (to-int #{rnm($c_half, $(- n_cols rect_offset))#} ))
    (setq cor_x rect_offset)
    (setq cor_y rect_offset)
    (setq cor_q (- n_rows rect_offset))
    (setq cor_z (- n_cols rect_offset))


    ;(==> this make-random-state dens_o)
    (array-clear cells 0)
    (assert (and (> cor_x 0)(> cor_y 0)(< cor_q (- n_rows 1))(< cor_z (- n_cols 1))(> (- cor_q cor_x) 1)(> (- cor_z cor_y) 1))
	    (sprintf "RECT_BOUND.INIT: Out of bounds index dens_i= %f dens_o= %f x=%d y=%d q=%d z=%d rect %d x %d \n" dens_i dens_o cor_x cor_y cor_q cor_z(- cor_q cor_x) (- cor_z cor_y) ))

    (let* ((ic (==> this get_ic))
	   (width (- cor_q cor_x))
	   (height (- cor_z cor_y))
	   (ic_i (idx-trim* ic width height))
	   (ic_row (idx-trim ic 0 cor_x 1))
	   (ic_col (idx-trim ic 1 cor_y 1))
	   (x 0) (y 0)
	   (count 0))
      (declare (-idx2- (-ubyte-)) ic ic_i)
      (declare (-idx2- (-ubyte-)) ic_row ic_col)
      (declare (-int-) x y width height count)

      (setq dens_i 1)
      (setq dens_o 0)

      ;;shift over internal rect to x, y cord
      (idx-shift! ic_i 0 cor_x)
      (idx-shift! ic_i 1 cor_y)
      (decr width)
      (decr height)
      ;;initialize internal rect with dens_i
      (for* (i 0 n_points)
	(declare (-int-) i)
	(setq x (to-int #{rnm(0, $width)#} ))
	(setq y (to-int #{rnm(0, $height)#} ))
	(ic_i x y 1))

      ;;reset x, y coordinates to smallest and largest row index that is  
      ;; occupied by the first and last "1" (cor_x and cor_q) respectively 
      (setq x n_rows)
      (setq y 0)
      (for* (i cor_x (+ cor_q 1))
	(declare (-int-) i)
	(setq count ((idx-sum ic_row)))
	(when (> count 0)
	  (when (< i x)
	    (setq cor_x i)
	    (setq x i))
	  (when (>= i y)
     	    (setq cor_q i)))
	(idx-shift! ic_row 0 1))
      (incr cor_q)                   ;;closing coordinate must include last row 
	

      ;; do the same as above for columns
      (setq x n_cols)
      (setq y 0)
      (for* (i cor_y (+ cor_z 1))
	(declare (-int-) i)
	(setq count ((idx-sum ic_col)))
	(when (> count 0)
	  (when (< i x)
	    (setq cor_y i)
	    (setq x i))
	  (when (>= i y)
	    (setq cor_z i)))
	(idx-shift! ic_col 1 1))
      (incr cor_z)                  ;;closing coordinate must include last col

      ;(printf "new cors: x:%d y:%d q:%d z:%d size: %d x %d\n" cor_x cor_y cor_q cor_z (- cor_q cor_x) (- cor_z cor_y))	    
      (==> this set_ic ic)
      ic)
    ))

;;takes IC w/ internal rect dens_i in ambient dens_o
;;fitness of IC is sum of all incorrect pixels' distance from the 
;; closest edge of the rectangle
;; example: line of IC with vert. rect. border "|" would add 5+3 to fitness
;; 00010000|11011111
(defmethod RectBound calculate_fitness()
  (let ((bit_o 1)
	(bit_i 0)
	;(fitness 0)
	(ic (==> this get_ic)))
    (declare (-int-) bit_i bit_o)
    ;(declare (-double-) fitness)
    (declare (-idx2- (-ubyte-)) ic)

    (setq fitness 0)
    ;;flip-flop inside bit and outside bit values when densities are switched
    (when (> dens_o dens_i)
      (setq bit_o 0)
      (setq bit_i 1))

    ;(printf "in calc fit\n")
    (for* (i 0 (idx-shape ic 0))
      (for* (j 0 (idx-shape ic 1))
	(declare (-int-) i j)
	;;inside of rect (boundary are part of rect
	(if (and (>= i cor_x)(< i cor_q)(>= j cor_y)(< j cor_z))
	    (if (= bit_i (ic i j))                    ;; wrong bit
		;(progn (printf "Wrong bit inside i:%d j:%d x:%d y:%d q:%d z:%d \n" i j cor_x cor_y cor_q cor_z)
		(setq fitness (+ fitness  (min (+ (- i cor_x) 1) (+ (- j cor_y) 1) (- cor_q i) (- cor_z j)))))
	        ;)
	  ;;outside of rect
	  (if (= bit_o (ic i j))                      ;; wrong bit
	     ;(progn (printf "Wrong bit outside i:%d j:%d x:%d y:%d q:%d z:%d \n" i j cor_x cor_y cor_q cor_z)
	      ;;N of rect
	      (cond ((and (< i cor_x)(>= j cor_y)(<= j cor_z))
		     (setq fitness (+ fitness (- cor_x i))))
		    ;;W or rect
		    ((and (>= i cor_x)(<= i cor_q)(< j cor_y)) 
		     (setq fitness (+ fitness (- cor_y j))))
		    ;;S or rect
		    ((and (>= i cor_q)(>= j cor_y)(<= j cor_z))
		     (setq fitness (+ fitness (- i cor_q) 1)))
		    ;;E of rect
		    ((and (>= i cor_x)(<= i cor_q)(>= j cor_z))
		     (setq fitness (+ fitness (- j cor_z) 1)))
		    ;;NW of rect
		    ((and (< i cor_x)(< j cor_y))
		     (setq fitness (+ fitness (to-int (sqrt (+ (** (- cor_y j) 2) (** (- cor_x i) 2)))))))
		    ;;SW of rect
		    ((and (> i cor_q)(< j cor_y))
		     (setq fitness (+ fitness (to-int (sqrt (+ (** (- i cor_q) 2) (** (- cor_y j) 2)))))))
		    ;;NE of rect
		    ((and (< i cor_x)(> j cor_z))
		     (setq fitness (+ fitness (to-int (sqrt (+ (** (- j cor_z) 2) (** (- cor_x i) 2)))))))
		    ;;SE of rect
		    ((and (> i cor_q)(> j cor_z))
		     (setq fitness (+ fitness (to-int (sqrt (+ (** (- j cor_z) 2) (** (- i cor_q) 2)))))))
		    (t (printf "Fitness:%f of pixel x:%d y:%d not evaluated (corx:%d cory:%d corq:%d corz:%d)\n" fitness i j cor_x cor_y cor_q cor_z)))
	      ;)
	    ))
	))
    ;(printf "f: %f \n" fitness)
    fitness))

;;OUTPUT: returns actual number of IC rows w/o borders
(defmethod RectBound get_nrows()
  n_rows)
;;OUTPUT: returns actual number of IC columns w/o borders
(defmethod RectBound get_ncols()
  n_cols)

;;Calulates and sets internal and external density (using rectangle coordinates)
;;        and sets repsective values dens_i dens_o 
;;OUTPUT: returns list of calculates densities (dens_i dens_o)
;;BUG: WORKS only for back rect and white background
(defmethod RectBound calculate_density()
  ;;calculate and set dens_i dens_o
  (let* ((ic (==> this get_ic))
	 (ic_i (idx-trim* ic (- cor_q cor_x) (- cor_z cor_y)))      ;internal ic rect
	 (size_i (* (idx-shape ic_i 0) (idx-shape ic_i 1)))         ;number of sites in inside rect
	 (size_o (- (* (idx-shape ic 0) (idx-shape ic 1)) size_i))  ;number of sites in outdise rect w/o inside rect
	 (count_i 0))                                               ;count of 1's of inside rect
    (declare (-int-) size_i size_o count_i)
    (declare (-idx2- (-ubyte-)) ic_i)

    ;;shift over internal rect to x, y cord
    (idx-shift! ic_i 0 cor_x)
    (idx-shift! ic_i 1 cor_y)
    (setq count_i ((idx-sum ic_i [d@ 0])))
    (setq dens_i (/ count_i size_i))
    (setq dens_o (/ (- ((idx-sum ic [d@ 0])) count_i) size_o ))
    ))

;;OUTPUT: returns dens_i density
(defmethod RectBound get_dens_i()
  dens_i)
;;OUTPUT: returns dens_o density
(defmethod RectBound get_dens_o()
  dens_o)

;;INPUT: sets densities dens_i dens_o and clears ic
(defmethod RectBound set_dens(di do)
  (declare (-double-) di do)
  (setq dens_i di)
  (setq dens_o do)
  (array-clear cells 0)
  (==> this clear_log))

;;INPUT: returns dens_o density
(defmethod RectBound get_dens_o()
  dens_o)

(defmethod RectBound get_cor ()
  (i_vector cor_x cor_y cor_q cor_z))

;;set values of rect bounding object
;;pass ic value to ca
(defmethod RectBound set_rect (ic cor)
  (declare (-idx2- (-ubyte-)) ic)
  (declare (-idx1- (-int-)) cor)

  (==> this set_ic ic)
  (setq cor_x (cor 0))
  (setq cor_y (cor 1))
  (setq cor_q (cor 2))
  (setq cor_z (cor 3))

  ;;calculate and set dens_i dens_o
  (==> this calculate_density)
  t)

;;PRECONDITION: must be preceeded by caluculate_fitness call
;;OUTPUT: returns fitness value caluclated on IC 
(defmethod RectBound get_fitness()
  fitness)

;;OUTPUT: return t if rect bounding is classified.
;;        correct is: square is black and surround is white or vice versa
;;                    calculate_fitness function knows which case it is
(defmethod RectBound classified()
  (if (= fitness 0) 
      t
    ()))

;;PRECONDITIONS: loaded LUT and IC
;;evaluates LUT on a given IC for max of <iters>
;;OUTPUT: 1 if classification correct
;;        0 if classifciation incorrect 
;;          or not done withing max # of iters
(defmethod RectBound evaluate_lut(iter)
  (declare (-int-) iter)
  
  (==> this calculate_fitness)
  (while (and (> iter 0 ) (<> (==> this classified) t))
    (decr iter)
    (==> this update)
    (==> this calculate_fitness))
  ;; if classified correctly return 1 and 0 o.w.
  (if (= (==> this classified) t)
      1
    0)
)

;; Test performance on randomly created ICs
;; <exp> number of restarts 
;; <iter> max number of  itterations of CA on IC 
;; <den> if 0 use uniform distribution 
;;       if >0 do binomial distribution with bias of <den>
;; <vrb> verbal vs nonverbal mode  
(defmethod RectBound testPerfRnd (exp iter den vrb)
  (let ((i 0)
	(run 0) 
	(suc 0))
    (declare (-int-) exp iter i run suc vrb)
    (declare (-double-) den)
    ;;set densities equal - will regenerate densities of internal and external rect.
    (setq dens_i dens_o)
    (while (< i exp)  ;;run experiments
      ;(if (> den 0)                           ;;initialize the IC
      ;  (==> this make-random-state den)
      ; (==> this make-random-state (to-double #{uniform()#})))

      (==> this init)
      ;(==> this set_idens)                    ;;set initial density

      ;; test LUT on IC 
      (if (= (==> this evaluate_lut iter) 1)
	  (incr suc))

      (if (= vrb 1)                           ;;if verbose print state information
	  (printf "Something is happening!")
	)
      (setq run 0)
      (incr i))
    (if (= vrb 1)
	(printf "\nPerformance of this rule is: %f \n" (to-float (* (/ suc exp) 100))))
     (/ suc exp)))

(let ((dhc-make-lushflags (concat dhc-make-lushflags (sprintf " -I%s" PROJECTxDIR))))
  (dhc-make-class () RectBound))

;; draw IC state into current window; cell-size is in pixels 
(defmethod RectBound show_ic (&optional (cell-size 3))
  (let ((window (new-window 0 0 (* rows cell-size) 
			(* cols cell-size) "Current IC state")))
    (gray-draw-matrix 0 0 (==> this get_ic) 1 0 cell-size cell-size)
    window
    ))

(libload "libc/make")
(libload "../random.lsh")
(libload "../ca_bit.lsh")
(libload "../setup.lsh")
(libload (concat lushdir "/lsh/libc/stdio.lsh"))
;(libload (concat lushdir "/lsh/libc/libc.lsh"))

;; Object performs tests using CA object 
;; it maintains state information about CA experiment
(defclass DensClassification CellularAutomaton
  ((-int-) n_row n_col)
  ((-double-) i_dens)
)

;; Test CA; maintains state information about CA
;; <m> number of rows in CA
;; <n> number of columns in CA
(defmethod DensClassification DensClassification (m n)
  (cpheader "#include \"random.h\"")
  (declare (-int-) m n) 
  (==> this CellularAutomaton  m n) ;;inherits constructor
  (setq n_row m)
  (setq n_col n))

;; set initial density with current density from CA
(defmethod DensClassification set_idens() (setq i_dens density))

;; decide if classification was correct return t if yes
(defmethod DensClassification correct()
  (if (or (and (< i_dens 0.5) (= density 0))
	  (and (> i_dens 0.5) (= density 1)))
      t
    ()))

;; decide if classification is concluded return t if yes
(defmethod DensClassification classified()
  (if (or (= density 0) (= density 1))
      t
    ()))

;; returns initial density
(defmethod DensClassification get_idens() i_dens)

;; returns number of rows
(defmethod DensClassification get_nrow() n_row)

;; returns number of columns
(defmethod DensClassification get_ncol() n_col)

;;PRECONDITIONS: loaded LUT and IC
;;evaluates LUT on a given IC for max of <iters>
;;OUTPUT: 1 if classification correct
;;        0 if classifciation incorrect 
;;          or not done withing max # of iters
(defmethod DensClassification evaluate_lut(iter)
  (declare (-int-) iter)
  (==> this set_idens)
  (while (and (> iter 0 ) (<> (==> this classified) t))
    (decr iter)
    (==> this update))
  ;; if classified correctly return 1 and 0 o.w.
  (if (and (= (==> this classified) t) (= (==> this correct) t))
      1
    0)
)

;;Test performance from a file
;;!!!not done; don't use!!!!
#!
(defmethod DensClassification testPerfFn (fn exp iter den vrb)
 (let ((i 0)
	(run 0) 
	(suc 0))
    (declare (-int-) exp iter i run suc vrb)
    (declare (-double-) den)
    (declare (-str-) fn)
    #{   
       printf ("fn %s ", $fn);
    #}
1))
!#

;; Test performance on randomly created ICs
;; <exp> number of restarts 
;; <iter> max number of  itterations of CA on IC 
;; <den> if 0 use uniform distribution 
;;       if >0 do binomial distribution with bias of <den>
;; <vrb> verbal vs nonverbal mode  
(defmethod DensClassification testPerfRnd (exp iter den vrb)
  (let ((i 0)
	(run 0) 
	(suc 0))
    (declare (-int-) exp iter i run suc vrb)
    (declare (-double-) den)
    (while (< i exp)  ;;run experiments
      (if (> den 0)                           ;;initialize the IC
	  (==> this make-random-state den)
	(==> this make-random-state (to-double #{uniform()#})))
      ;(==> this set_idens)                    ;;set initial density

      ;; test LUT on IC 
      (if (= (==> this evaluate_lut iter) 1)
	  (incr suc))

      (if (= vrb 1)                           ;;if verbose print state information
	  (printf "PerfRun: %d IDens: %f CDens: %f  Success: %d  SucClass: %d\n" 
		  i (to-double(==> this get_idens)) (to-double (==> this get_dens)) 
		  (to-int (if (= (==> this correct) t) 1 0)) suc))
      (setq run 0)
      (incr i))
    (if (= vrb 1)
	(printf "\nPerformance of this rule is: %f \n" (to-float (* (/ suc exp) 100))))
     (/ suc exp)))


(let ((dhc-make-lushflags (concat dhc-make-lushflags (sprintf " -I%s" PROJECTxDIR))))
  (dhc-make-class () DensClassification))

(defun perfFile (fn)
  (declare (-str-) fn)
1)

(dhc-make "perfFile" perfFile)
